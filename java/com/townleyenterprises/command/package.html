<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
//////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2003-2004, Andrew S. Townley
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
//     * Redistributions of source code must retain the above
//     copyright notice, this list of conditions and the following
//     disclaimer.
//
//     * Redistributions in binary form must reproduce the above
//     copyright notice, this list of conditions and the following
//     disclaimer in the documentation and/or other materials provided
//     with the distribution.
//
//     * Neither the names Andrew Townley and Townley Enterprises,
//     Inc. nor the names of its contributors may be used to endorse
//     or promote products derived from this software without specific
//     prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
// OF THE POSSIBILITY OF SUCH DAMAGE.
//
// File:	package.html
// Author:	Andrew S. Townley (adz1092@yahoo.com)
// Created:	Sun May 11 20:05:12 IST 2003
//
// $Id: package.html,v 1.4 2004/07/28 10:33:58 atownley Exp $
//
//////////////////////////////////////////////////////////////////////
-->

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>
com.townleyenterprises.console Package Documentation
</title>
</head>
<body>
<p>
Provides classes to assist in easily creating command-line
Java applications.  The implementation is roughly based on
the Red Hat popt library, but is not intended to be
compatible with this API.
</p>

<center>
<a href="#usage">Usage</a> | <a href="#limitations">Limitations</a>
</center>

<h3>
<a name="usage">
Usage
</a>
</h3>

<p>
There are basically two ways to use this package.  The first
approach is probably most familiar to users of the Red Hat popt
packages and C programmers used to processing command line
arguments in general, while the second approach applies
Object Oriented Programming principles to handling the
arguments.  With either approach, there is complete support
for accessing additional or "left over" arguments which are
supplied on the command line but which do not explicitly
apply to a single option.
</p>

<h4>
The Classic Model
</h4>

<p>
With this usage model, the application wishing to
respond to command line arguments simply defines instances
of the arguments it wishes to recognize and then registers
itself as a <code>CommandListener</code> with the appropriate
<code>CommandParser</code>
instance.  After this is done, most of the work of dealing
with the application takes place in the <code>CommandListener</code>'s
implementation of <code>optionMatched</code>
method.  While there is nothing wrong with this approach (it
will be very familiar to anyone who has used the popt or
similar libraries), it can easily result in a <em>very</em>
large <code>if</code> statement if the application supports
many long options or many <code>case</code>'s of a
<code>switch</code> statement if primarily short options are
used.
</p>
<p>
<pre>
	import com.townleyenterprises.command.*;

	public class cltest implements CommandListener
	{
		static  CommandOption[] opts = {
			new CommandOption("foo", 'f',
					false, null, "isn't this foo?"),
			new CommandOption("bar", 'b',
					true, "&lt;name>", "specifies the bar"),
			new CommandOption("only-long", (char)0,
					true, "&lt;opt>",
					"this option only has a long form")
		};

		public CommandOption[] getOptions()
		{
			return opts;
		}

		public void optionMatched(CommandOption opt, String arg)
		{
			switch(opt.getShortName().charValue())
			{
				case 'f':
					System.out.println("matched f");
					break;
				case 'b':
					System.out.println("matched bar:  " + arg);
					break;
			}
		}

		public String getName()
		{
			return "cltest options";
		}

		public static void main(String[] args)
		{
			CommandParser clp = new CommandParser("cltest");
			clp.addCommandListener(new cltest());
			clp.parse(args);

			String[] largs = clp.getUnhandledArguments();
			for(int i = 0; i &lt; largs.length; ++i)
			{
				System.out.println("largs[" + i + "] = '" +
					largs[i] + "'");
			}
		}
	}
</pre>
<center><strong><em>Example 1:  Classic Command Parsing</em></strong></center>
</p>
<p>
If the command-line parsing needs of an application are
modest, this approach is easy to understand and
straightforward to implement quickly.  However, applications
which have more complex command-line argument handling needs
might be better off using the object-oriented approach.
</p>

<h4>
The Object-Oriented Model
</h4>
<p>
Since this library does not intend to be compatible with
existing command-line parsing libraries and since Java is an
object-oriented language, it makes sense to also provide an
OO approach to the command-line argument problem.  Rather
than separating the behavior of what should happen when each
option is matched from the option itself, the normal
operations of detecting if the option has been matched and
capturing the option argument is encapsulated into the
<code>CommandOption</code> class.
</p>
<p>
The <code>ComandParser</code> calls the
<code>optionMatched</code> method of each option it
matches before it notifies all of the registered listeners.  In the
default case, the method simply sets a boolean value to
indicate if the option has been matched and captures the
argument for later retrieval.  If the option is
declared as a named object rather than as an anonymous
object in the <code>CommandObject</code> array returned from
the listener, the application can check if the option has
been matched by simply asking the option.  There is no need
to provide any code in the listener's
<code>optionMatched</code> method.  This approach is
illustrated in Example 2.  </p>

<a name="example2">
<p>
<pre>
	import com.townleyenterprises.command.*;

	public class cltest implements CommandListener
	{
		static CommandOption doa = new CommandOption("aop",
				'a', false, null,
				"The 'a' operation should be performed");
		static CommandOption dob = new CommandOption("bop",
				'b', false, null,
				"The 'b' operation should be performed");
		static CommandOption doc = new CommandOption("cop",
				'c', false, null,
				"The 'c' operation should be performed");

		static	CommandOption[] opts = { doa, dob, doc };

		public CommandOption[] getOptions()
		{
			return opts;
		}

		public void optionMatched(CommandOption opt, String arg)
		{
			// nothing to do
		}

		public String getDescription()
		{
			return "cltest options";
		}

		public static void main(String[] args)
		{
			CommandParser clp = new CommandParser("cltest");
			clp.addCommandListener(new cltest());
			clp.parse(args);

			if(doa.getMatched())
			{
				System.out.println("Supposed to do a");
			}

			if(dob.getMatched())
			{
				System.out.println("Supposed to do b");
			}

			if(doc.getMatched())
			{
				System.out.println("Supposed to do c");
			}

			String[] largs = clp.getUnhandledArguments();
			for(int i = 0; i &lt; largs.length; ++i)
			{
				System.out.println("largs[" + i + "] = '" +
					largs[i] + "'");
			}
		}
	}
</pre>
<center><strong><em>Example 2:  OO Command Parsing Take 1</em></strong></center>
</p>
</a>

<p>
The above example might not seem to be a large improvement
over the Classic Mode at first glance.  The main advantage
in this case is that the application is going to do
something more complicated than print some text if any of
the options, or any combination of the options, have been
matched by the command parser.  Using the Classic Mode or in
some other command-line parsing libraries, boolean values
would have to be set in the listener's <code>optionMatched</code>
method.  This approach partially approximates the flag
concept present in the popt library.
</p>
<p>
A variation on Example 2 may be used by applications which
want to perform all argument parsing and then perform the
requested actions rather than potentially performing only
some of the requested commands.  This approach also does not
require the listener to implement a body to the
<code>optionMatched</code> method.  Each argument must be
named and is responsible for capturing the arguments for
later use.  This technique can be implemented simply by
making minor modifications to <a href="#example2">Example
2</a> as shown below:
</p>
<p>
<pre>
	import com.townleyenterprises.command.*;

	public class cltest implements CommandListener
	{
		static CommandOption doa = new CommandOption("aop",
				'a', true, "&lt;arg&gt;",
				"The 'a' operation should be performed");
		static CommandOption dob = new CommandOption("bop",
				'b', true, "&lt;arg&gt;",
				"The 'b' operation should be performed");
		static CommandOption doc = new CommandOption("cop",
				'c', false, null,
				"The 'c' operation should be performed");

		static	CommandOption[] opts = { doa, dob, doc };

		public CommandOption[] getOptions()
		{
			return opts;
		}

		public void optionMatched(CommandOption opt, String arg)
		{
			// nothing to do
		}

		public String getDescription()
		{
			return "cltest options";
		}

		public static void main(String[] args)
		{
			CommandParser clp = new CommandParser("cltest");
			clp.addCommandListener(new cltest());
			clp.parse(args);

			if(doa.getMatched())
			{
				System.out.println("Supposed to do a using '"
					+ doa.getArg() + "'");
			}

			if(dob.getMatched())
			{
				System.out.println("Supposed to do b using '"
					+ dob.getArg() + "'");
			}

			if(doc.getMatched())
			{
				System.out.println("Supposed to do c");
			}

			String[] largs = clp.getUnhandledArguments();
			for(int i = 0; i &lt; largs.length; ++i)
			{
				System.out.println("largs[" + i + "] = '" +
					largs[i] + "'");
			}
		}
	}
</pre>
<center><strong><em>Example 3:  OO Command Parsing Take 2</em></strong></center>
</p>
<p>
The facilities described above should handle most of the
command-line argument parsing needs of an application in a
more efficient manner than is often required when using a non-OO
approach.  The specific parameters and switches which are
often created within the application to determine if
arguments have been matched have been replaced with allowing
the options to track themselves, thus removing a lot of
tedious programming overhead from the application developer.
</p>
<p>
However, to handle the remainder of the possible needs of
command line option parsing, it is possible to provide
additional behavior by deriving a new class from the
<code>CommandOption</code> class and implementing additional
behavior in the <code>optionMatched</code> method.  The most
obvious examples of this type of need would be:

<ul>
<li>The application wants to take specific actions
immediately when options are matched.
</li>
<li>The application wishes to support specifying the same
option more than once on the command line with a cumulative
effect.
</li>
<li>
The application wishes to return another Java type than a
String, or perform additional validation of the arguments
during command processing instead of afterwards.
</li>
</ul>
</p>

<p>
As an example, take a hypothetical Java program which works
on directories and files.  The program can optionally exclude
any files or directories in the list of files to process by
using the <code>--exclude</code> option.  If the Classic
Model was used, the specific logic to handle multiple
instances of the option would be embedded in the
<code>CommandListener</code>.  However, the library provides a clean way
to implement this feature in a reusable way.  Example 4
illustrates a way to implement this functionality.
</p>

<p>
<pre>
	import java.util.*;
	import com.townleyenterprises.command.*;

	class RepeatableOption extends CommandOption
	{
		RepeatableOption(String longName, char shortName,
				String argHelp, String argDesc)
		{
			super(longName, shortName, true, argHelp, argDesc);
		}

		public void optionMatched(String arg)
		{
			super.optionMatched(arg);
			_args.add(arg);
		}

		List getArgs()
		{
			return _args;
		}

		ArrayList	_args = new ArrayList();
	}


	public class feather implements CommandListener
	{
		static CommandOption create = new CommandOption("create", 'c',
				false, null, "Create a new archive.");
		static CommandOption file = new CommandOption("file", 'f',
				true, "&lt;filename&gt;",
				"Specify the name of the archive"
					+ " (default is stdout).");
		static RepeatableOption xclude = new RepeatableOption("exclude",
				'X', "[ &lt;filename&gt; | &lt;directory&gt; ]",
				"Exclude the named file or directory"
					+ " from the archive");

		static	CommandOption[] opts = { create, file, xclude };

		public CommandOption[] getOptions()
		{
			return opts;
		}

		public void optionMatched(CommandOption opt, String arg)
		{
			// nothing to do
		}

		public String getDescription()
		{
			return "feather options";
		}

		public static void main(String[] args)
		{
			CommandParser clp = new CommandParser("feather",
					"FILE...");
			clp.addCommandListener(new feather());
			clp.parse(args);

			if((file.getMatched() || xclude.getMatched()) &&
					!create.getMatched())
			{
				System.err.println("error:  nothing to do");
				clp.usage();
				System.exit(-1);
			}

			String[] largs = clp.getUnhandledArguments();
			if(create.getMatched() && largs.length == 0)
			{
				System.err.println("error:  refusing "
					+ "to create empty archive.");
				clp.usage();
				System.exit(-2);
			}

			for(int i = 0; i < largs.length; ++i)
			{
				System.out.println("largs[" + i + "] = '" +
					largs[i] + "'");
			}

			if(xclude.getMatched())
			{
				System.out.println("Excluded:");

				List xas = xclude.getArgs();
				for(Iterator j = xas.iterator(); j.hasNext();)
				{
					System.out.println(j.next());
				}
			}
		}
	}
</pre>
<center><strong><em>Example 4:  Putting it All Together</em></strong></center>
</p>
<p>
The above code will correctly process the following command
line:
<pre>
	$ java feather -X /tmp -X /var -c -f out.feather /

</pre>
and print the following output:
<pre>

	largs[0] = '/'
	Excluded:
	/tmp
	/var

</pre>
</p>
<p>
The library is designed to make parsing command lines easy
and to eliminate the tedious nature of doing so, much in the
same way that the javax.swing.Action class streamlined the
handling of GUI events.  However, the application developer
ultimately is the one making the decision about how the
library best fits in with the way they want do develop the
application.  Both the Classic Model and the OO Model have
been used in production code and both work equally well.
The main difference is in how much extra, repetative code
must be written to perform the same tasks.
</p>

<h3>
<a name="limitations">
Limitations
</a>
</h3>

<p>
At the present time, the following limitations/issues are
present in the package:

<ul>
<li>
<strong>Lack of i18n/l10n support</strong> -- at the
moment, all of the diagnostics and text which is issued from
the command parser is in English.  It isn't difficult to fix
and will be present in a future release.
</li>
<li>
<strong>Assumes 80 character terminal</strong> -- There
doesn't seem to be a good way to get the terminal width in a
portable fashion from the Java Virtual Machine.
</li>
<li>
<strong>No support for combined options</strong> -- There is
currently no support for options which start with the short
switch character and are longer than one character.  This
means that you cannot parse command line options of the
forms:
<pre>
	-display
	-500
	-cvzf
</pre>
</li>
</ul>
</p>
</body>
</html>
